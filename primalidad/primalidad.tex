\documentclass{beamer}

\mode<presentation>
{
  \usetheme{Warsaw}
  \useoutertheme{infolines}
  \usecolortheme{spruce}
  % or ...

  \definecolor{beamer@verdeSoft}{rgb}{0.337,0.866,0.341}
  \definecolor{beamer@verdeDark}{rgb}{0.01,0.326,0.01}
  \setbeamercolor{item projected}{bg=green}
  \setbeamercolor{section in toc}{fg = beamer@verdeDark}
  \setbeamercolor{block title}{fg=beamer@verdeDark, bg = beamer@verdeSoft}
  %\setbeamercolor{local structure}{fg=green}

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage{hyperref}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{listings}

\lstloadlanguages{C++}
\lstnewenvironment{code}
	{%\lstset{	numbers=none, frame=lines, basicstyle=\small\ttfamily, }%
	 \csname lst@SetFirstLabel\endcsname}
	{\csname lst@SaveFirstLabel\endcsname}
\lstset{% general command to set parameter(s)
	language=C++, basicstyle=\footnotesize\sffamily, keywordstyle=\slshape,
	emph=[1]{tipo,usa}, emphstyle={[1]\sffamily\bfseries},
	morekeywords={tint,forn,forsn},
	basewidth={0.47em,0.40em},
	columns=fixed, fontadjust, resetmargins, xrightmargin=5pt, xleftmargin=15pt,
	flexiblecolumns=false, tabsize=2, breaklines,	breakatwhitespace=false, extendedchars=true,
	numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=9pt,
	frame=l, framesep=3pt,
}

\usepackage[spanish]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


\title[Programación Dinámica] % (optional, use only with long paper titles)
{Primalidad y factorización}

\author[Agustín Gutiérrez] % (optional, use only with lots of authors)
{~Agustín Santiago Gutiérrez}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.
\institute[UBA] % (optional, but mostly needed)
{
  Facultad de Ciencias Exactas y Naturales\\
  Universidad de Buenos Aires
}
\date[Camp 2016] % (optional, should be abbreviation of conference name)
{Campamento Caribeño ACM-ICPC 2016}

% Acá se puede insertar el logo de la UBA
% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}{Contenidos}
  \footnotesize
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

\AtBeginSubsubsection[]
{
  \begin{frame}{Contenidos}
  \footnotesize
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Contenidos}
  \tableofcontents
  % You might wish to add the option [pausesections]
\end{frame}



\section{Aritmética modular}

\subsection{Operaciones, estructura}

\begin{frame}{Definición}
  \begin{block}{Aritmética módulo $M$ ($\mathbb{Z}_M$)}
  La aritmética módulo $M$ consiste en una modificación de la aritmética usual de números enteros, en la cual trabajamos únicamente con el \textit{resto} de los números al ser divididos por un cierto entero fijo $M>0$,
  ignorando ``todo lo demás'' de los números involucrados.
  \end{block}
  \begin{itemize}
      \pause
      \invisible<1>{\item Así, $11 = 18$ si estamos trabajando módulo $7$, pues ambos dejan un resto de $4$ en la división por $7$. Esto se suele notar $11 \equiv 18 (\mbox{mód } 7)$}
      \pause
      \invisible<1-2>{\item Una forma operacional de ver esta aritmética es suponer que todo el tiempo tenemos los números reducidos al rango de enteros en $[0,M)$, y tomamos el resto de la división por $M$ para devolverlos a ese rango luego de cada operación.}
  \end{itemize}
\end{frame}

\begin{frame}{Propiedades}
    A los efectos de realizar sumas, restas y productos, la aritmética módular es análoga a la aritmética usual, manteniendo sus propiedades importantes.
  \begin{itemize}
       \item $a+b \equiv b+a (\mbox{mód } M)$
       \item $(a+b)+c \equiv a+(b+c) (\mbox{mód }M)$
       \item $0$ es el neutro de la suma.
       \item Para todo $a$ existe un único inverso aditivo modular $-a$, $a + (-a) \equiv  0 (\mbox{mód } M)$. $a-b  \equiv  a + (-b) (\mbox{mód }M)$
       \item $a \cdot b \equiv b \cdot a (\mbox{mód } M)$
       \item $(a \cdot b) \cdot c \equiv a \cdot (b \cdot c) (\mbox{mód } M)$
       \item $1$ es el neutro del producto.
       \item $(a+b) \cdot c \equiv a \cdot c + b \cdot c (\mbox{mód } M)$
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Forma operacional en el código}
Supongamos que se tiene que computar una suma de los números enteros \texttt{a[0]} hasta \texttt{a[N-1]}, pero solamente nos importan los últimos 4 dígitos (equivale a trabajar módulo 10000).

\begin{columns}
\begin{column}{0.65\textwidth}
\begin{lstlisting}
int result = 0;
for (int i = 0; i < N; i++)
    result = (result + a[i]) % 10000;
\end{lstlisting}
\end{column}
\end{columns}

Como decíamos antes, a nivel de operaciones trabajar con aritmética modular equivale a simplemente tomar módulo luego de cada operación aritmética básica.

\end{frame}

\begin{frame}{Problema ante números negativos}
Sin embargo, la implementación anterior puede resultar problemática al trabajar con números \textbf{negativos}.

\begin{itemize}
    \item Si por ejemplo fuera $N=2$, \texttt{a[0]=123} y \texttt{a[1]=-200}, el código anterior produce -77, que puede no ser lo deseado.
    \item Incluso si no hay números negativos en el problema, es muy común que \textbf{restemos} números en nuestra solución.
    \item Estos resultados con valores negativos ocurren porque el resultado de la división entera se redondea hacia cero en los lenguajes y plataformas más populares.
    \pause
    \invisible<1-1>{\item Solución: \\ \texttt{int MOD(int x, int M)\{return ((x\%M)+M)\%M;\}} }
\end{itemize}

\end{frame}

\begin{frame}{Cuidado con el overflow}
\begin{itemize}
    \item Otro problema al que es especialmente común enfrentarse al trabajar con aritmética modular es el peligro de tener overflow en las operaciones.

    \item Por esto es que tomamos módulo luego de cada operación, y no solamente al final de todo el programa.
    
    \item Truquito en C++: Tener en cuenta el tipo \texttt{\_\_int128}, entero de 128 bits. No está presente en todo judge, pero puede ser muy útil cuando está disponible.

\end{itemize}
\end{frame}

\begin{frame}{¿Qué pasa con la división?}
\begin{itemize}
    \item ¿Podemos operar modularmente con la división tal cual lo hacemos con sumas, restas y productos?

    \pause
    \invisible<1-1>{
        \item \textbf{NO}. Por ejemplo: \\
             $\frac{10}{2}\equiv 5 (\mbox{mód } 8)$, pero $10 \equiv 2 (\mbox{mód } 8)$ y $\frac{2}{2} \equiv 1 \not\equiv 5 (\mbox{mód } 8)$
        \item Podemos garantizar que este ``truco'' funciona cuando el módulo es un número \textbf{primo}. \\
             $\frac{27}{3}\equiv 2 (\mbox{mód } 7)$, $27 \equiv 6 (\mbox{mód } 7)$ y $\frac{6}{3} \equiv 2 (\mbox{mód } 7)$ \\
             Pero solo si el divisor \textbf{no es cero} (módulo $p$) \\
             $\frac{140}{14}\equiv 3 (\mbox{mód } 7)$, pero $140 \equiv 14 \equiv 0 (\mbox{mód } 7)$ y $\frac{0}{0} \equiv ? (\mbox{mód } 7)$ \\
        \pause
        \invisible<1-2>{
            \item ¿Pero y si aún con un módulo primo, la división modular no resulta una división entera? \\
                 $\frac{12}{3}\equiv 4 (\mbox{mód } 7)$, pero $12 \equiv 5 (\mbox{mód } 7)$ y $\frac{5}{3} \equiv ? (\mbox{mód } 7)$ \\
        }
    }

\end{itemize}
\end{frame}

\begin{frame}{Inversos modulares}
    \begin{block}{Definición}
       Decimos que $b$ es inverso de $a$ módulo $M$ si $a \cdot b \equiv 1 (\mbox{mód } M)$.
    \end{block}
    Notar que solo un $a \not \equiv 0 (\mbox{mód } M)$ podría tener un inverso, y de existir el inverso es único, y a su vez $a$ resulta ser el inverso de $b$.
\pause
      \invisible<1>{
        \begin{block}{Teorema}
           Si $p$ es un número primo, entonces todo número $a \not \equiv 0 (\mbox{mód } p)$ tiene un inverso módulo $p$.
        \end{block}
        }

\end{frame}

\begin{frame}{Inversos modulares: utilidad}
    \begin{itemize}
        \item Recordemos que para realizar $3 / 2 = 1.5$, en realidad podríamos multiplicar directamente por el inverso de $2$, es decir $3 \cdot 0.5 = 1.5$
        \item Lo mismo podemos hacer modularmente. Por ejemplo, $5 \cdot 3 \equiv 1 (\mbox{mód } 7)$, así que $inv(3)=5$. Y entonces recordando el ejemplo anterior:\\
               $\frac{12}{3}\equiv 4 (\mbox{mód } 7)$, \\ $12 \equiv 5 (\mbox{mód } 7)$ y \\$\mbox{``}\frac{5}{3}\mbox{''} \equiv 5 \cdot inv(3) \equiv 5 \cdot 5 \equiv 4 (\mbox{mód } 7)$ 
        \item De esta forma, ya podemos dividir modularmente al trabajar con un número primo (excepto cuando el divisor se hace $0$ módulo $p$).
        \item ¿Pero cómo calculamos los inversos?
    \end{itemize}

\end{frame}

\subsection{Fermat e inversos modulares}

\begin{frame}{Pequeño teorema de Fermat}
  \begin{block}{Teorema}
  Si $p$ es primo y $a \not \equiv 0 (\mbox{mód } p)$, entonces $a^{p-1} \equiv 1 (\mbox{mód } p)$
  \end{block}
  \begin{itemize}
      \item Por ejemplo $6^{30} = 7131416765184947029025 \cdot 31 + 1$
      \item ¿Para qué puede servir este teorema?
  \end{itemize}
\end{frame}

\begin{frame}{Aplicación 1: Cálculo de inversos}
  \begin{itemize}
      \item Recordemos que dado $a \not \equiv 0$, si encontramos algún número $x$ tal que $a \cdot x \equiv 1 (\mbox{mód } p)$, $x$ será automáticamente el inverso de $a$.
      \item Si tomamos $x = a^{p-2}$, ¿Cuánto vale $a \cdot x$?
      \pause
      \invisible<1-1>{
        \item Tenemos $a \cdot x = a^{p-1} \equiv 1 (\mbox{mód } p)$ por el Pequeño Teorema de Fermat.
        \item Luego para cada $a$ su inverso será simplemente $a^{p-2}$.
      }
  \end{itemize}
\end{frame}

\begin{frame}{Aplicación 2: Testeo de residuo cuadrático}
  \begin{block}{Definición}
  Un resto $r$ se dice un \textit{residuo cuadrático} módulo $p$ si existe $x$ tal que $x^2 \equiv r (\mbox{mód } p)$
  \end{block}
  Por ejemplo los residuos cuadráticos módulo $5$ son $0,1,4$. Notar que $0$ siempre es residuo cuadrático módulo $p$.
  \begin{itemize}
          \item Si $r \not \equiv 0$ es residuo cuadrático, ¿Cuánto vale $r^{\frac{p-1}{2}}$?
          \pause
      \invisible<1-1>{
          \item $r \equiv x^2$ para algún $x \not \equiv 0$, y entonces $r^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv 1 (\mbox{mód } p)$
          \item Se puede verificar que además si para algún $r$ vale $r^{\frac{p-1}{2}} \equiv 1 (\mbox{mód } p)$, $r$ es residuo cuadrático módulo $p$.
      }
  \end{itemize}
\end{frame}

\subsection{Potenciación logarítmica}

\begin{frame}{Potenciación logarítmica}
  \begin{itemize}
      \item En los ejemplos anteriores hemos reducido algunos problemas a calcular $a^b$ módulo $M$, para enteros no negativos $a,b,M$.
      \item ¿Cómo hacemos esto más eficientemente que realizando $b-1$ multiplicaciones?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Potenciación logarítmica}
\begin{columns}
\begin{column}{0.60\textwidth}
\begin{lstlisting}
typedef long long tint;
tint potlog(tint a,tint b, const tint M)
{
    tint res = 1;
    while (b > 0)
    {
        if (b%  2 != 0)
            res = MOD(res*a, M);
        a = MOD(a*a, M);
        b /= 2;
    }
    return res;
}\end{lstlisting}
\end{column}
\begin{column}{0.45\textwidth}
Invariante de ciclo:

La respuesta que deseamos es $res \cdot (a^b \mbox{ módulo } M)$

Este método realiza solamente $O(\lg b)$ multiplicaciones.
\end{column}
\end{columns}
\end{frame}

\section{Primalidad}

\subsection{Criba}

\subsection{Verificación directa}

\subsubsection{Algoritmo ingenuo}

\subsubsection{Test de Rabin - Miller}

\section{Factorización}

\subsection{Criba}

\subsection{Factorización directa}

\ 

\subsubsection{Algoritmo ingenuo}

\ 

\subsubsection{Factorización rápida}

\ 

%\subsubsection{Algoritmo de la liebre y la tortuga de Floyd}

\ 

%\subsubsection{Algoritmo de la $\rho$ de Pollard}

\ 


\end{document}
