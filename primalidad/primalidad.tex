\documentclass{beamer}

\mode<presentation>
{
  \usetheme{Warsaw}
  \useoutertheme{infolines}
  \usecolortheme{spruce}
  % or ...

  \definecolor{beamer@verdeSoft}{rgb}{0.337,0.866,0.341}
  \definecolor{beamer@verdeDark}{rgb}{0.01,0.326,0.01}
  \setbeamercolor{item projected}{bg=green}
  \setbeamercolor{section in toc}{fg = beamer@verdeDark}
  \setbeamercolor{block title}{fg=beamer@verdeDark, bg = beamer@verdeSoft}
  %\setbeamercolor{local structure}{fg=green}

  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage{hyperref}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{siunitx}
\usepackage{colortbl}

\lstloadlanguages{C++}
\lstnewenvironment{code}
	{%\lstset{	numbers=none, frame=lines, basicstyle=\small\ttfamily, }%
	 \csname lst@SetFirstLabel\endcsname}
	{\csname lst@SaveFirstLabel\endcsname}
\lstset{% general command to set parameter(s)
	language=C++, basicstyle=\footnotesize\sffamily, keywordstyle=\slshape,
	emph=[1]{tipo,usa}, emphstyle={[1]\sffamily\bfseries},
	morekeywords={tint,forn,forsn},
	basewidth={0.47em,0.40em},
	columns=fixed, fontadjust, resetmargins, xrightmargin=5pt, xleftmargin=15pt,
	flexiblecolumns=false, tabsize=2, breaklines,	breakatwhitespace=false, extendedchars=true,
	numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=9pt,
	frame=l, framesep=3pt,
}

% Para mechar color en el texto
\lstset{escapeinside={<<<@}{@>>>}}

\usepackage[spanish]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


\title[Programación Dinámica] % (optional, use only with long paper titles)
{Primalidad y factorización}

\author[Agustín Gutiérrez] % (optional, use only with lots of authors)
{~Agustín Santiago Gutiérrez}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.
\institute[UBA] % (optional, but mostly needed)
{
  Facultad de Ciencias Exactas y Naturales\\
  Universidad de Buenos Aires
}
\date[Camp 2016] % (optional, should be abbreviation of conference name)
{Campamento Caribeño ACM-ICPC 2016}

% Acá se puede insertar el logo de la UBA
% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}{Contenidos}
  \footnotesize
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

\AtBeginSubsubsection[]
{
  \begin{frame}{Contenidos}
  \footnotesize
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Contenidos}
  \tableofcontents
  % You might wish to add the option [pausesections]
\end{frame}



\section{Aritmética modular}

\subsection{Operaciones, estructura}

\begin{frame}{Definición}
  \begin{block}{Aritmética módulo $M$ ($\mathbb{Z}_M$)}
  La aritmética módulo $M$ consiste en una modificación de la aritmética usual de números enteros, en la cual trabajamos únicamente con el \textit{resto} de los números al ser divididos por un cierto entero fijo $M>0$,
  ignorando ``todo lo demás'' de los números involucrados.
  \end{block}
  \begin{itemize}
      \pause
      \invisible<1>{\item Así, $11 = 18$ si estamos trabajando módulo $7$, pues ambos dejan un resto de $4$ en la división por $7$. Esto se suele notar $11 \equiv 18 (\mbox{mód } 7)$}
      \pause
      \invisible<1-2>{\item Una forma operacional de ver esta aritmética es suponer que todo el tiempo tenemos los números reducidos al rango de enteros en $[0,M)$, y tomamos el resto de la división por $M$ para devolverlos a ese rango luego de cada operación.}
  \end{itemize}
\end{frame}

\begin{frame}{Propiedades}
    A los efectos de realizar sumas, restas y productos, la aritmética módular es análoga a la aritmética usual, manteniendo sus propiedades importantes.
  \begin{itemize}
       \item $a+b \equiv b+a (\mbox{mód } M)$
       \item $(a+b)+c \equiv a+(b+c) (\mbox{mód }M)$
       \item $0$ es el neutro de la suma.
       \item Para todo $a$ existe un único inverso aditivo modular $-a$, $a + (-a) \equiv  0 (\mbox{mód } M)$. $a-b  \equiv  a + (-b) (\mbox{mód }M)$
       \item $a \cdot b \equiv b \cdot a (\mbox{mód } M)$
       \item $(a \cdot b) \cdot c \equiv a \cdot (b \cdot c) (\mbox{mód } M)$
       \item $1$ es el neutro del producto.
       \item $(a+b) \cdot c \equiv a \cdot c + b \cdot c (\mbox{mód } M)$
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Forma operacional en el código}
Supongamos que se tiene que computar una suma de los números enteros \texttt{a[0]} hasta \texttt{a[N-1]}, pero solamente nos importan los últimos 4 dígitos (equivale a trabajar módulo 10000).

\begin{columns}
\begin{column}{0.65\textwidth}
\begin{lstlisting}
int result = 0;
for (int i = 0; i < N; i++)
    result = (result + a[i]) % 10000;
\end{lstlisting}
\end{column}
\end{columns}

Como decíamos antes, a nivel de operaciones trabajar con aritmética modular equivale a simplemente tomar módulo luego de cada operación aritmética básica.

\end{frame}

\begin{frame}{Problema ante números negativos}
Sin embargo, la implementación anterior puede resultar problemática al trabajar con números \textbf{negativos}.

\begin{itemize}
    \item Si por ejemplo fuera $N=2$, \texttt{a[0]=123} y \texttt{a[1]=-200}, el código anterior produce -77, que puede no ser lo deseado.
    \item Incluso si no hay números negativos en el problema, es muy común que \textbf{restemos} números en nuestra solución.
    \item Estos resultados con valores negativos ocurren porque el resultado de la división entera se redondea hacia cero en los lenguajes y plataformas más populares.
    \pause
    \invisible<1-1>{\item Solución: \\ \texttt{int MOD(int x, int M)\{return ((x\%M)+M)\%M;\}} }
\end{itemize}

\end{frame}

\begin{frame}{Cuidado con el overflow}
\begin{itemize}
    \item Otro problema al que es especialmente común enfrentarse al trabajar con aritmética modular es el peligro de tener overflow en las operaciones.

    \item Por esto es que tomamos módulo luego de cada operación, y no solamente al final de todo el programa.
    
    \item Truquito en C++: Tener en cuenta el tipo \texttt{\_\_int128}, entero de 128 bits. No está presente en todo judge, pero puede ser muy útil cuando está disponible.

\end{itemize}
\end{frame}

\begin{frame}{¿Qué pasa con la división?}
\begin{itemize}
    \item ¿Podemos operar modularmente con la división tal cual lo hacemos con sumas, restas y productos?

    \pause
    \invisible<1-1>{
        \item \textbf{NO}. Por ejemplo: \\
             $\frac{10}{2}\equiv 5 (\mbox{mód } 8)$, pero $10 \equiv 2 (\mbox{mód } 8)$ y $\frac{2}{2} \equiv 1 \not\equiv 5 (\mbox{mód } 8)$
        \item Podemos garantizar que este ``truco'' funciona cuando el módulo es un número \textbf{primo}. \\
             $\frac{27}{3}\equiv 2 (\mbox{mód } 7)$, $27 \equiv 6 (\mbox{mód } 7)$ y $\frac{6}{3} \equiv 2 (\mbox{mód } 7)$ \\
             Pero solo si el divisor \textbf{no es cero} (módulo $p$) \\
             $\frac{140}{14}\equiv 3 (\mbox{mód } 7)$, pero $140 \equiv 14 \equiv 0 (\mbox{mód } 7)$ y $\frac{0}{0} \equiv ? (\mbox{mód } 7)$ \\
        \pause
        \invisible<1-2>{
            \item ¿Pero y si aún con un módulo primo, la división modular no resulta una división entera? \\
                 $\frac{12}{3}\equiv 4 (\mbox{mód } 7)$, pero $12 \equiv 5 (\mbox{mód } 7)$ y $\frac{5}{3} \equiv ? (\mbox{mód } 7)$ \\
        }
    }

\end{itemize}
\end{frame}

\begin{frame}{Inversos modulares}
    \begin{block}{Definición}
       Decimos que $b$ es inverso de $a$ módulo $M$ si $a \cdot b \equiv 1 (\mbox{mód } M)$.
    \end{block}
    Notar que solo un $a \not \equiv 0 (\mbox{mód } M)$ podría tener un inverso, y de existir el inverso es único, y a su vez $a$ resulta ser el inverso de $b$.
\pause
      \invisible<1>{
        \begin{block}{Teorema}
           Si $p$ es un número primo, entonces todo número $a \not \equiv 0 (\mbox{mód } p)$ tiene un inverso módulo $p$.
        \end{block}
        }

\end{frame}

\begin{frame}{Inversos modulares: utilidad}
    \begin{itemize}
        \item Recordemos que para realizar $3 / 2 = 1.5$, en realidad podríamos multiplicar directamente por el inverso de $2$, es decir $3 \cdot 0.5 = 1.5$
        \item Lo mismo podemos hacer modularmente. Por ejemplo, $5 \cdot 3 \equiv 1 (\mbox{mód } 7)$, así que $inv(3)=5$. Y entonces recordando el ejemplo anterior:\\
               $\frac{12}{3}\equiv 4 (\mbox{mód } 7)$, \\ $12 \equiv 5 (\mbox{mód } 7)$ y \\$\mbox{``}\frac{5}{3}\mbox{''} \equiv 5 \cdot inv(3) \equiv 5 \cdot 5 \equiv 4 (\mbox{mód } 7)$ 
        \item De esta forma, ya podemos dividir modularmente al trabajar con un número primo (excepto cuando el divisor se hace $0$ módulo $p$).
        \item ¿Pero cómo calculamos los inversos?
    \end{itemize}

\end{frame}

\subsection{Fermat e inversos modulares}

\begin{frame}{Pequeño teorema de Fermat}
  \begin{block}{Teorema}
  Si $p$ es primo y $a \not \equiv 0 (\mbox{mód } p)$, entonces $a^{p-1} \equiv 1 (\mbox{mód } p)$
  \end{block}
  \begin{itemize}
      \item Por ejemplo $6^{30} = 7131416765184947029025 \cdot 31 + 1$
      \item ¿Para qué puede servir este teorema?
  \end{itemize}
\end{frame}

\begin{frame}{Aplicación 1: Cálculo de inversos}
  \begin{itemize}
      \item Recordemos que dado $a \not \equiv 0$, si encontramos algún número $x$ tal que $a \cdot x \equiv 1 (\mbox{mód } p)$, $x$ será automáticamente el inverso de $a$.
      \item Si tomamos $x = a^{p-2}$, ¿Cuánto vale $a \cdot x$?
      \pause
      \invisible<1-1>{
        \item Tenemos $a \cdot x = a^{p-1} \equiv 1 (\mbox{mód } p)$ por el Pequeño Teorema de Fermat.
        \item Luego para cada $a$ su inverso será simplemente $a^{p-2}$.
      }
  \end{itemize}
\end{frame}

\begin{frame}{Aplicación 2: Testeo de residuo cuadrático}
  \begin{block}{Definición}
  Un resto $r$ se dice un \textit{residuo cuadrático} módulo $p$ si existe $x$ tal que $x^2 \equiv r (\mbox{mód } p)$
  \end{block}
  Por ejemplo los residuos cuadráticos módulo $5$ son $0,1,4$. Notar que $0$ siempre es residuo cuadrático módulo $p$.
  \begin{itemize}
          \item Si $r \not \equiv 0$ es residuo cuadrático, ¿Cuánto vale $r^{\frac{p-1}{2}}$?
          \pause
      \invisible<1-1>{
          \item $r \equiv x^2$ para algún $x \not \equiv 0$, y entonces $r^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv 1 (\mbox{mód } p)$
          \item Se puede verificar que además si para algún $r$ vale $r^{\frac{p-1}{2}} \equiv 1 (\mbox{mód } p)$, $r$ es residuo cuadrático módulo $p$.
      }
  \end{itemize}
\end{frame}

\subsection{Potenciación logarítmica}

\begin{frame}{Potenciación logarítmica}
  \begin{itemize}
      \item En los ejemplos anteriores hemos reducido algunos problemas a calcular $a^b$ módulo $M$, para enteros no negativos $a,b,M$.
      \item ¿Cómo hacemos esto más eficientemente que realizando $b-1$ multiplicaciones?
  \end{itemize}
\end{frame}

\begin{frame}{Potenciación logarítmica (idea)}
  \begin{itemize}
      \item Una buena idea es pensar en ir elevando al cuadrado sucesivamente, lo cual permite que el exponente crezca rápidamente.
      \item Pensado de manera recursiva, si llamamos $f(a,n) = a^n$: \\
              $\begin{array}{rcl}
                     f(a,n) & = & \left \{ \begin{array}{cl}
                                              1  & \mbox{si }n=0 \\
                                              f \left (a^2, \frac{n}{2} \right ) & \mbox{si } n \mbox{ es par} \\
                                              a \cdot f \left (a^2, \left \lfloor \frac{n}{2} \right \rfloor \right ) & \mbox{si } n \mbox{ es impar} \\
                                           \end{array} \right . \\
               \end{array}$
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Potenciación logarítmica (código)}
\begin{columns}
\begin{column}{0.60\textwidth}
\begin{lstlisting}
typedef long long tint;
tint potlog(tint a,tint b, const tint M)
{
    tint res = 1;
    while (b > 0)
    {
        if (b%  2 != 0)
            res = MOD(res*a, M);
        a = MOD(a*a, M);
        b /= 2;
    }
    return res;
}\end{lstlisting}
\end{column}
\begin{column}{0.45\textwidth}
Invariante de ciclo:

La respuesta que deseamos es $res \cdot (a^b \mbox{ módulo } M)$

Este método realiza solamente $O(\lg b)$ multiplicaciones.
\end{column}
\end{columns}
\end{frame}

\section{Primalidad}

\subsection{Criba}

\begin{frame}{Problema}
  \begin{itemize}
      \item Una necesidad muy usual al trabajar con números primos es la de calcular \textit{todos} los primos desde $1$ hasta $N$ para un cierto $N$.
      \item La idea es realizarlo de manera más eficiente que verificando la primalidad de cada número por separado.
  \end{itemize}
\end{frame}

\begin{frame}{Idea 1}
  \begin{itemize}
      \item Si verificásemos cada número por separado, lo que haríamos sería recorrer sus posibles \textbf{divisores} para ver si es primo.
      \item ¿Que pasaría si en lugar de probar los divisores de cada número, descartásemos sus \textbf{múltiplos}?
      \pause
      \invisible<1-1>{
           \item Hay $\frac{N}{1}$ múltiplos de $1$, $\frac{N}{2}$ múltiplos de $2$, $\cdots \frac{N}{N}$ múltiplos de $N$. Luego si recorremos todo
            el costo total es
            
            $$\sum_{i=1}^N{\frac{N}{i}} = N \sum_{i=1}^N{\frac{1}{i}} = \Theta(N \lg N)$$
      }
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Idea 1 (cont.)}
  \begin{itemize}
      \item Esta idea es verdaderamente muy sencilla, y como vimos ya alcanza una eficiencia aceptable.
      \item Además, al recorrer los múltiplos de todos los números, se encuentran todos los divisores propios de todos los números.
      \item De esta forma es extremadamente fácil modificar esta versión para computar fácilmente sumas de divisores, cantidades, y otras funciones similares.
  \end{itemize}

\begin{lstlisting}
    for(int i = 0; i < MAX; i++) p[i] = true;
    p[0] = p[1] = false;
    for (int i = 2; i < MAX; i++)
        for (int j = 2*i; j < MAX; j += i) p[j] = false;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Idea 2}
  \begin{itemize}
      \item Todo número compuesto tiene un divisor \textbf{primo}.
      \item Por lo tanto, alcanza con descartar los múltiplos de los números primos que vamos encontrando.
      \item La cantidad de operaciones a realizar en este caso se reduce a $\Theta(N \lg \lg N)$, que es ``casi lineal''.
  \end{itemize}

\begin{lstlisting}
    for(int i = 0; i < MAX; i++) p[i] = true;
    p[0] = p[1] = false;
    for (int i = 2; i < MAX; i++)
    <<<@\textcolor{red}{if (p[i])}@>>>
        for (int j = 2*i; j < MAX; j += i) p[j] = false;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Idea 3}
  \begin{itemize}
      \item Todo número compuesto tiene un divisor primo $p$, con $p \leq \sqrt{N}$ .
      \item Podemos parar el proceso de descarte de múltiplos en $\sqrt{N}$.
      \item La cantidad de operaciones sigue siendo $\Theta(N \lg \lg N)$.
  \end{itemize}

\begin{lstlisting}
    for(int i = 0; i < MAX; i++) p[i] = true;
    p[0] = p[1] = false;
    for (int i = 2; <<<@\textcolor{red}{i*i}@>>> < MAX; i++)
    if (p[i])
        for (int j = 2*i; j < MAX; j += i) p[j] = false;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Idea 4}
  \begin{itemize}
      \item De manera similar al caso anterior, si $N < p^2$ es compuesto, tiene un divisor primo menor que $p$, y ya habrá sido descartado.
      \item Podemos comenzar el descarte de los múltiplos de $i$ por $i^2$.
      \item Aún con esta optimización, la cantidad de operaciones sigue siendo $\Theta(N \lg \lg N)$.
  \end{itemize}

\begin{lstlisting}
    for(int i = 0; i < MAX; i++) p[i] = true;
    p[0] = p[1] = false;
    for (int i = 2; i*i < MAX; i++)
    if (p[i])
        for (int j = <<<@\textcolor{red}{i*i}@>>>; j < MAX; j += i) p[j] = false;
\end{lstlisting}
\end{frame}


\begin{frame}{Tiempos}
     Para \texttt{MAX=300M}:
     
     $$\begin{array}{rl}
           \mbox{\texttt{RecorrerMultiplos}} & \SI{39.1}{\second} \\
           \mbox{\texttt{CribaBasica}} & \SI{5.6}{\second} \\
           \mbox{\texttt{CribaHastaRaiz}} & \SI{3.2}{\second} \\
           \mbox{\texttt{CribaHastaRaizDesdeICuadrado}} & \SI{3.0}{\second} \\
       \end{array}$$
\end{frame}


\subsection{Verificación directa}

\subsubsection{Algoritmo ingenuo}

\begin{frame}{Algoritmo ingenuo}
  \begin{itemize}
      \item Como ya hemos mencionado, un número compuesto $N$ tendrá un divisor primo menor o igual a $\sqrt{N}$
      \item Un algoritmo simple $O(\sqrt{N})$ consistirá entonces de un chequeo de todos los números enteros en el rango $[2, \sqrt{N}]$,
             en busca de divisores de $N$.
  \end{itemize}
\end{frame}


\subsubsection{Test de Rabin - Miller}

\begin{frame}{Test de Rabin - Miller (Introducción)}
  \begin{itemize}
      \item El test de Rabin-Miller es un algoritmo \textbf{probabilístico}, muy eficiente para verificar si un número es primo.
      \item Se basa en su antecesor, el \textit{test de Fermat}.
      \item Recordemos: $a \not\equiv 0 (\mbox{mód } p) \Rightarrow a^{p-1} \equiv 1 (\mbox{mód } p)$
  \end{itemize}
\end{frame}

\begin{frame}{Test de Fermat}
  \begin{itemize}
      \item El test de Fermat es un test probabilístico para verificar si un número candidato $N$ es primo.
      \item Se selecciona para ello un entero al azar $a \in [1, N)$.
      \item Si $N$ es primo necesariamente será $a^{N-1} \equiv 1 (\mbox{mód } N)$, así que si esto no ocurre descartamos al número como primo.
      \item Si esto ocurre, el número pasó el test de Fermat con $a$ como testigo. El test puede repetirse con varios valores de $a$ para aumentar la confianza.
  \end{itemize}
\end{frame}

\begin{frame}{Test de Fermat: problema}
  \begin{itemize}
      \item El test de Fermat es eficiente, pero tiene un problema: existen ejemplos de números que pasan el test de Fermat para todo valor de $a$ coprimo con $N$, pero que son compuestos.
      \item Estos números extremos son raros y se denominan de \textit{Carmichael}. Los primeros son 561, 1105, 1729, 2465, 2821, 6601, 8911.
      \item Con estos números, el test solamente los detecta como compuestos si $a$ es múltiplo de uno de los primos que dividen a $N$, y por lo tanto el test es prácticamente una búsqueda de divisores aleatoria.
  \end{itemize}
\end{frame}

\begin{frame}{Test de Rabin - Miller (idea)}
  \begin{itemize}
      \item El test de Rabin-Miller elimina este problema verificando una condición más fuerte.
      \item Observemos que si $p > 2$ es primo y $x^2 = 1 (\mbox{mód } p)$, $x$ solo puede ser $1$ o $-1$ módulo $p$.
      \item Luego si $p-1 = 2^\alpha k$, con $k$ impar y $\alpha \geq 1$, tenemos que para cualquier $a \not \equiv 0 (\mbox{mód } p)$ debe ser $a^{2^\alpha k} \equiv 1 (\mbox{mód } p)$.
      \item Pero entonces $a^{2^{\alpha-1} k} \equiv 1 \mbox{ o } -1 (\mbox{mód } p)$
      \item Y si fuera $1$, entonces nuevamente $a^{2^{\alpha-2} k} \equiv 1 \mbox{ o } -1 (\mbox{mód } p)$
      \item Y así podemos repetir el razonamiento hasta que $a^{k} \equiv 1$ o bien $a^{2^j k} \equiv -1$ para algún $0 \leq j < \alpha$
  \end{itemize}
\end{frame}

\begin{frame}{Test de Rabin - Miller (idea cont.)}
  Tenemos entonces las siguientes posibilidades para el valor de $a^{2^jk}$ (una por columna):
  $$\begin{array}{rccccccc}
      \mathbf{j} & \  & \ & \   & \ & \ & \  \\
      \alpha & 1 & 1 & \cdots & 1 & 1 & 1 & 1  \\
      \alpha-1 & -1 & 1 & \cdots & 1 & 1 & 1 & 1     \\
      \alpha-2 & ? & -1 & \cdots & 1 & 1 & 1 & 1    \\
      \cdots & \cdots & \cdots & \cdots & \cdots  & \cdots & \cdots &  \cdots    \\
      2 & ? & ? & \cdots & -1 &  1 & 1  & 1\\
      1 & ? & ? & \cdots &  ? & -1 & 1  & 1 \\
      0 & ? & ? & \cdots &  ? &  ? & -1 & 1 \\
    \end{array}
  $$
\end{frame}

\begin{frame}{Test de Rabin - Miller (implementación)}
  En general estas son chequeadas desde abajo hacia arriba, de forma que cada valor necesario es el cuadrado del que se necesitó en el paso anterior:
  $$\begin{array}{rccccc>{\columncolor{blue!30}}c>{\columncolor{blue!30}}cl}
      \mathbf{j} & \  & \ & \   & \ & \ & \ & \\
      \alpha & 1 & 1 & \cdots & 1 & 1 & 1 & 1 & \\
      \alpha-1 & -1 & 1 & \cdots & 1 & 1 & 1 & 1 &    \\
      \alpha-2 & ? & -1 & \cdots & 1 & 1 & 1 & 1 &   \\
      \cdots & \cdots & \cdots & \cdots & \cdots  & \cdots & \cdots &  \cdots &   \\
      2 & ? & ? & \cdots & -1 &  1 & 1  & 1 &\\
      1 & ? & ? & \cdots &  ? & -1 & 1  & 1 & \\
      0 & ? & ? & \cdots &  ? &  ? & -1 & 1 & \cellcolor{blue!30} a^k \equiv 1 \mbox{ o } -1 \\
    \end{array}
  $$
\end{frame}

\begin{frame}{Test de Rabin - Miller (implementación)}
  En general estas son chequeadas desde abajo hacia arriba, de forma que cada valor necesario es el cuadrado del que se necesitó en el paso anterior:
  $$\begin{array}{rcccc>{\columncolor{blue!30}}cccl}
      \mathbf{j} & \  & \ & \   & \ & \ & \ & \\
      \alpha & 1 & 1 & \cdots & 1 & 1 & 1 & 1 & \\
      \alpha-1 & -1 & 1 & \cdots & 1 & 1 & 1 & 1 &    \\
      \alpha-2 & ? & -1 & \cdots & 1 & 1 & 1 & 1 &   \\
      \cdots & \cdots & \cdots & \cdots & \cdots  & \cdots & \cdots &  \cdots &   \\
      2 & ? & ? & \cdots & -1 &  1 & 1  & 1 &\\
      1 & ? & ? & \cdots &  ? & -1 & 1  & 1 & \cellcolor{blue!30} a^{2k} = (a^{k})^2 \equiv -1\\
      0 & ? & ? & \cdots &  ? &  ? & -1 & 1 & \\
    \end{array}
  $$
\end{frame}

\begin{frame}{Test de Rabin - Miller (implementación)}
  En general estas son chequeadas desde abajo hacia arriba, de forma que cada valor necesario es el cuadrado del que se necesitó en el paso anterior:
  $$\begin{array}{rccc>{\columncolor{blue!30}}ccccl}
      \mathbf{j} & \  & \ & \   & \ & \ & \ & \\
      \alpha & 1 & 1 & \cdots & 1 & 1 & 1 & 1 & \\
      \alpha-1 & -1 & 1 & \cdots & 1 & 1 & 1 & 1 &    \\
      \alpha-2 & ? & -1 & \cdots & 1 & 1 & 1 & 1 &   \\
      \cdots & \cdots & \cdots & \cdots & \cdots  & \cdots & \cdots &  \cdots &   \\
      2 & ? & ? & \cdots & -1 &  1 & 1  & 1 & \cellcolor{blue!30} a^{2^2k} = (a^{2k})^2 \equiv -1\\
      1 & ? & ? & \cdots &  ? & -1 & 1  & 1 & \\
      0 & ? & ? & \cdots &  ? &  ? & -1 & 1 & \\
    \end{array}
  $$
\end{frame}

\begin{frame}{Test de Rabin - Miller (implementación)}
  En general estas son chequeadas desde abajo hacia arriba, de forma que cada valor necesario es el cuadrado del que se necesitó en el paso anterior:
  $$\begin{array}{rc>{\columncolor{blue!30}}ccccccl}
      \mathbf{j} & \  & \ & \   & \ & \ & \ & \\
      \alpha & 1 & 1 & \cdots & 1 & 1 & 1 & 1 & \\
      \alpha-1 & -1 & 1 & \cdots & 1 & 1 & 1 & 1 &    \\
      \alpha-2 & ? & -1 & \cdots & 1 & 1 & 1 & 1 & \cellcolor{blue!30} a^{2^{\alpha-2}k} \equiv -1   \\
      \cdots & \cdots & \cdots & \cdots & \cdots  & \cdots & \cdots &  \cdots &   \\
      2 & ? & ? & \cdots & -1 &  1 & 1  & 1 & \\
      1 & ? & ? & \cdots &  ? & -1 & 1  & 1 & \\
      0 & ? & ? & \cdots &  ? &  ? & -1 & 1 & \\
    \end{array}
  $$
\end{frame}

\begin{frame}{Test de Rabin - Miller (implementación)}
  En general estas son chequeadas desde abajo hacia arriba, de forma que cada valor necesario es el cuadrado del que se necesitó en el paso anterior:
  $$\begin{array}{r>{\columncolor{blue!30}}cccccccl}
      \mathbf{j} & \  & \ & \   & \ & \ & \ & \\
      \alpha & 1 & 1 & \cdots & 1 & 1 & 1 & 1 & \\
      \alpha-1 & -1 & 1 & \cdots & 1 & 1 & 1 & 1 & \cellcolor{blue!30} a^{2^{\alpha-1}k} \equiv -1   \\
      \alpha-2 & ? & -1 & \cdots & 1 & 1 & 1 & 1 &   \\
      \cdots & \cdots & \cdots & \cdots & \cdots  & \cdots & \cdots &  \cdots &   \\
      2 & ? & ? & \cdots & -1 &  1 & 1  & 1 & \\
      1 & ? & ? & \cdots &  ? & -1 & 1  & 1 & \\
      0 & ? & ? & \cdots &  ? &  ? & -1 & 1 & \\
    \end{array}
  $$
\end{frame}

\begin{frame}{Test de Rabin - Miller (conclusión)}
    \begin{itemize}
      \item Si ninguno de los casos anteriores se da, concluímos que definitivamente el número no es primo.
      \item Si alguno funciona, ese valor de $a$ funciona y el número parece ser primo.
      \item Al igual que en el test de Fermat, conviene utilizar varios valores de $a$ para aumentar la confianza.
      \item En el caso del test de Rabin-Miller, tenemos la garantía de que si $N$ es compuesto, al menos el 75\% de los posibles restos $a$ no nulos módulo $N$ lo demostrarán usando el test.
      \item Por lo tanto si repetimos el test $k$ veces sobre un número compuesto, eligiendo números de manera aleatoria, uniforme e independiente, la probabilidad de error es como máximo $\frac{1}{4^k}$.
      \item Los números primos siempre pasan el test, y son reportados como tales.
  \end{itemize}
\end{frame}

\section{Factorización}

\subsection{Criba}

\begin{frame}[fragile]{Factorización logarítmica}
  \begin{itemize}
      \item Buena alternativa si nos interesa poder factorizar rápidamente cualquier número hasta $N$, y aceptamos el costo de una criba hasta $N$.
      \item Si en lugar de solamente guardar si un número es primo o no, guardamos un primo que lo divida mientras hacemos la criba, luego podemos saber un divisor primo de cualquier número en $O(1)$. Esto permite factorizar cualquier número en $O(\lg N)$.
  \end{itemize}

\begin{lstlisting}
    for(int i = 0; i < MAX; i++) p[i] = i;
    p[0] = p[1] = 1;
    for (int i = 2; i*i < MAX; i++)
    if (p[i] == i)
        for (int j = i*i; j < MAX; j += i) p[j] = i;
\end{lstlisting}
\end{frame}

\subsection{Factorización directa}

\ 

\subsubsection{Algoritmo ingenuo}

\ 

\subsubsection{Factorización rápida}

\ 

%\subsubsection{Algoritmo de la liebre y la tortuga de Floyd}

\ 

%\subsubsection{Algoritmo de la $\rho$ de Pollard}

\ 


\end{document}
